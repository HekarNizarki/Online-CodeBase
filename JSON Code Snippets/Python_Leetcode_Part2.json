{
    "Python_Leetcode_with_code": [
        {
            "title": "Add Two Numbers",
            "code": "class ListNode:\n    def __init__(self,val=0,next=None):\n        self.val=val\n        self.next=next\n\ndef addTwoNumbers(l1,l2):\n    dummy=ListNode()\n    current=dummy\n    carry=0\n    while l1 or l2 or carry:\n        val1=l1.val if l1 else 0\n        val2=l2.val if l2 else 0\n        total=val1+val2+carry\n        carry=total//10\n        current.next=ListNode(total%10)\n        current=current.next\n        l1=l1.next if l1 else None\n        l2=l2.next if l2 else None\n    return dummy.next"
        },
        {
            "title": "Longest Substring Without Repeating Characters",
            "code": "def lengthOfLongestSubstring(s):\n    char_set=set()\n    left=0\n    max_length=0\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left+=1\n        char_set.add(s[right])\n        max_length=max(max_length,right-left+1)\n    return max_length"
        },
        {
            "title": "Longest Palindromic Substring",
            "code": "def longestPalindrome(s):\n    def expand(left,right):\n        while left>=0 and right<len(s) and s[left]==s[right]:\n            left-=1\n            right+=1\n        return s[left+1:right]\n    result=''\n    for i in range(len(s)):\n        odd=expand(i,i)\n        even=expand(i,i+1)\n        result=max(result,odd,even,key=len)\n    return result"
        },
        {
            "title": "Container With Most Water",
            "code": "def maxArea(height):\n    left,right=0,len(height)-1\n    max_area=0\n    while left<right:\n        max_area=max(max_area,min(height[left],height[right])*(right-left))\n        if height[left]<height[right]:\n            left+=1\n        else:\n            right-=1\n    return max_area"
        },
        {
            "title": "3Sum",
            "code": "def threeSum(nums):\n    nums.sort()\n    result=[]\n    for i in range(len(nums)-2):\n        if i>0 and nums[i]==nums[i-1]:\n            continue\n        left,right=i+1,len(nums)-1\n        while left<right:\n            total=nums[i]+nums[left]+nums[right]\n            if total<0:\n                left+=1\n            elif total>0:\n                right-=1\n            else:\n                result.append([nums[i],nums[left],nums[right]])\n                while left<right and nums[left]==nums[left+1]:\n                    left+=1\n                while left<right and nums[right]==nums[right-1]:\n                    right-=1\n                left+=1\n                right-=1\n    return result"
        },
        {
            "title": "Remove Nth Node From End of List",
            "code": "class ListNode:\n    def __init__(self,val=0,next=None):\n        self.val=val\n        self.next=next\n\ndef removeNthFromEnd(head,n):\n    dummy=ListNode(0,head)\n    slow=fast=dummy\n    for _ in range(n+1):\n        fast=fast.next\n    while fast:\n        slow=slow.next\n        fast=fast.next\n    slow.next=slow.next.next\n    return dummy.next"
        },
        {
            "title": "Letter Combinations of a Phone Number",
            "code": "def letterCombinations(digits):\n    if not digits:\n        return []\n    digit_to_letters={'2':'abc','3':'def','4':'ghi','5':'jkl','6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}\n    result=[]\n    def backtrack(index,path):\n        if index==len(digits):\n            result.append(''.join(path))\n            return\n        for letter in digit_to_letters[digits[index]]:\n            backtrack(index+1,path+[letter])\n    backtrack(0,[])\n    return result"
        },
        {
            "title": "Generate Parentheses",
            "code": "def generateParenthesis(n):\n    result=[]\n    def backtrack(s,left,right):\n        if len(s)==2*n:\n            result.append(s)\n            return\n        if left<n:\n            backtrack(s+'(',left+1,right)\n        if right<left:\n            backtrack(s+')',left,right+1)\n    backtrack('',0,0)\n    return result"
        },
        {
            "title": "Swap Nodes in Pairs",
            "code": "class ListNode:\n    def __init__(self,val=0,next=None):\n        self.val=val\n        self.next=next\n\ndef swapPairs(head):\n    dummy=ListNode(0,head)\n    prev=dummy\n    while head and head.next:\n        first=head\n        second=head.next\n        prev.next=second\n        first.next=second.next\n        second.next=first\n        prev=first\n        head=first.next\n    return dummy.next"
        },
        {
            "title": "Search in Rotated Sorted Array",
            "code": "def search(nums,target):\n    left,right=0,len(nums)-1\n    while left<=right:\n        mid=(left+right)//2\n        if nums[mid]==target:\n            return mid\n        if nums[left]<=nums[mid]:\n            if nums[left]<=target<nums[mid]:\n                right=mid-1\n            else:\n                left=mid+1\n        else:\n            if nums[mid]<target<=nums[right]:\n                left=mid+1\n            else:\n                right=mid-1\n    return -1"
        },
        {
            "title": "Combination Sum",
            "code": "def combinationSum(candidates,target):\n    result=[]\n    def backtrack(start,path,remaining):\n        if remaining==0:\n            result.append(path)\n            return\n        for i in range(start,len(candidates)):\n            if candidates[i]>remaining:\n                continue\n            backtrack(i,path+[candidates[i]],remaining-candidates[i])\n    backtrack(0,[],target)\n    return result"
        },
        {
            "title": "Permutations",
            "code": "def permute(nums):\n    result=[]\n    def backtrack(path,remaining):\n        if not remaining:\n            result.append(path)\n            return\n        for i in range(len(remaining)):\n            backtrack(path+[remaining[i]],remaining[:i]+remaining[i+1:])\n    backtrack([],nums)\n    return result"
        },
        {
            "title": "Rotate Image",
            "code": "def rotate(matrix):\n    n=len(matrix)\n    for i in range(n//2):\n        for j in range(i,n-i-1):\n            temp=matrix[i][j]\n            matrix[i][j]=matrix[n-j-1][i]\n            matrix[n-j-1][i]=matrix[n-i-1][n-j-1]\n            matrix[n-i-1][n-j-1]=matrix[j][n-i-1]\n            matrix[j][n-i-1]=temp"
        },
        {
            "title": "Group Anagrams",
            "code": "def groupAnagrams(strs):\n    from collections import defaultdict\n    anagrams=defaultdict(list)\n    for s in strs:\n        key=''.join(sorted(s))\n        anagrams[key].append(s)\n    return list(anagrams.values())"
        },
        {
            "title": "Maximum Product Subarray",
            "code": "def maxProduct(nums):\n    if not nums:\n        return 0\n    max_prod=min_prod=result=nums[0]\n    for num in nums[1:]:\n        if num<0:\n            max_prod,min_prod=min_prod,max_prod\n        max_prod=max(num,max_prod*num)\n        min_prod=min(num,min_prod*num)\n        result=max(result,max_prod)\n    return result"
        },
        {
            "title": "Find First and Last Position of Element in Sorted Array",
            "code": "def searchRange(nums,target):\n    def find_left(nums,target):\n        left,right=0,len(nums)-1\n        while left<=right:\n            mid=(left+right)//2\n            if nums[mid]<target:\n                left=mid+1\n            else:\n                right=mid-1\n        return left\n    def find_right(nums,target):\n        left,right=0,len(nums)-1\n        while left<=right:\n            mid=(left+right)//2\n            if nums[mid]<=target:\n                left=mid+1\n            else:\n                right=mid-1\n        return right\n    left=find_left(nums,target)\n    right=find_right(nums,target)\n    return [left,right] if left<=right else [-1,-1]"
        },
        {
            "title": "Jump Game",
            "code": "def canJump(nums):\n    last_pos=len(nums)-1\n    for i in range(len(nums)-1,-1,-1):\n        if i+nums[i]>=last_pos:\n            last_pos=i\n    return last_pos==0"
        },
        {
            "title": "Merge Intervals",
            "code": "def merge(intervals):\n    intervals.sort(key=lambda x:x[0])\n    merged=[]\n    for interval in intervals:\n        if not merged or merged[-1][1]<interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1]=max(merged[-1][1],interval[1])\n    return merged"
        },
        {
            "title": "Unique Paths",
            "code": "def uniquePaths(m,n):\n    dp=[[1]*n for _ in range(m)]\n    for i in range(1,m):\n        for j in range(1,n):\n            dp[i][j]=dp[i-1][j]+dp[i][j-1]\n    return dp[-1][-1]"
        },
        {
            "title": "Minimum Path Sum",
            "code": "def minPathSum(grid):\n    m,n=len(grid),len(grid[0])\n    for i in range(1,m):\n        grid[i][0]+=grid[i-1][0]\n    for j in range(1,n):\n        grid[0][j]+=grid[0][j-1]\n    for i in range(1,m):\n        for j in range(1,n):\n            grid[i][j]+=min(grid[i-1][j],grid[i][j-1])\n    return grid[-1][-1]"
        },
        {
            "title": "Decode Ways",
            "code": "def numDecodings(s):\n    if not s:\n        return 0\n    dp=[0]*(len(s)+1)\n    dp[0]=1\n    dp[1]=1 if s[0]!='0' else 0\n    for i in range(2,len(s)+1):\n        if s[i-1]!='0':\n            dp[i]+=dp[i-1]\n        if 10<=int(s[i-2:i])<=26:\n            dp[i]+=dp[i-2]\n    return dp[-1]"
        },
        {
            "title": "Word Break",
            "code": "def wordBreak(s,wordDict):\n    word_set=set(wordDict)\n    dp=[False]*(len(s)+1)\n    dp[0]=True\n    for i in range(1,len(s)+1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i]=True\n                break\n    return dp[-1]"
        },
        {
            "title": "Linked List Cycle II",
            "code": "class ListNode:\n    def __init__(self,val=0,next=None):\n        self.val=val\n        self.next=next\n\ndef detectCycle(head):\n    slow=fast=head\n    while fast and fast.next:\n        slow=slow.next\n        fast=fast.next.next\n        if slow==fast:\n            slow=head\n            while slow!=fast:\n                slow=slow.next\n                fast=fast.next\n            return slow\n    return None"
        },
        {
            "title": "Sort Colors",
            "code": "def sortColors(nums):\n    low,mid,high=0,0,len(nums)-1\n    while mid<=high:\n        if nums[mid]==0:\n            nums[low],nums[mid]=nums[mid],nums[low]\n            low+=1\n            mid+=1\n        elif nums[mid]==1:\n            mid+=1\n        else:\n            nums[mid],nums[high]=nums[high],nums[mid]\n            high-=1"
        },
        {
            "title": "Subsets",
            "code": "def subsets(nums):\n    result=[]\n    def backtrack(start,path):\n        result.append(path)\n        for i in range(start,len(nums)):\n            backtrack(i+1,path+[nums[i]])\n    backtrack(0,[])\n    return result"
        }
    ]
}